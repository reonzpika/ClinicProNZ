# RBAC Patterns & Usage Enforcement

## üîí Role Hierarchy & Permissions

### Role Structure (Strict Order)
```typescript
type UserRole = 'public' | 'signed_up' | 'standard' | 'admin';

// Higher index = more permissions
const ROLE_HIERARCHY = ['public', 'signed_up', 'standard', 'admin'];
```

### Tier Mapping & Limits
```typescript
type UserTier = 'basic' | 'standard' | 'admin';

const ROLE_TO_TIER = {
  'public': 'basic',
  'signed_up': 'basic',  
  'standard': 'standard',
  'admin': 'admin'
};

const TIER_LIMITS = {
  basic: {
    coreSessions: 5,           // Transcription + note generation
    premiumActions: 5,         // Photo analysis, DDx, checklists, RAG
    templateManagement: false,
    sessionManagement: false
  },
  standard: {
    coreSessions: -1,          // Unlimited
    premiumActions: 5,         // Still limited
    templateManagement: true,
    sessionManagement: true
  },
  admin: {
    coreSessions: -1,          // Unlimited
    premiumActions: -1,        // Unlimited
    templateManagement: true,
    sessionManagement: true
  }
};
```

## üõ°Ô∏è Implementation Patterns

### 1. Component Role Checking
```typescript
// ‚úÖ CORRECT - Use utility hook
import { useClerkMetadata } from '@/src/shared/hooks/useClerkMetadata';

const Component = () => {
  const { getUserRole, hasRole } = useClerkMetadata();
  
  if (!hasRole('signed_up')) {
    return <UpgradePrompt />;
  }
  
  return <ProtectedContent />;
};

// ‚ùå AVOID - Direct metadata access
const role = user?.publicMetadata?.role as UserRole; // Type unsafe
```

### 2. API Route Protection Pattern
```typescript
// In middleware.ts - Route-level protection
if (req.nextUrl.pathname.startsWith('/api/templates')) {
  const { userId, sessionClaims } = await auth();
  const role = sessionClaims?.metadata?.role || 'public';
  
  if (role === 'public') {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
}

// In API route - Business logic protection
import { extractRBACContext, enforceUsageLimit } from '@/src/lib/rbac-enforcer';

export async function POST(req: Request) {
  const context = await extractRBACContext(req);
  
  // Check usage limits before processing
  await enforceUsageLimit(context, 'coreSessions', 1);
  
  // Business logic...
}
```

### 3. Server Component Role Checking
```typescript
import { auth } from '@clerk/nextjs/server';
import { getCurrentRole, checkRole } from '@/src/shared/utils/roles';

export default async function Page() {
  const hasAccess = await checkRole('signed_up');
  
  if (!hasAccess) {
    redirect('/login');
  }
  
  return <ProtectedPage />;
}
```

## üìä Usage Limit Enforcement

### RBAC Context Extraction
```typescript
// Support both authenticated users and guest tokens
export async function extractRBACContext(req: Request): Promise<RBACContext> {
  const guestToken = req.headers.get('x-guest-token') || null;
  
  // Try Clerk auth first (authenticated users take priority)
  try {
    const { userId, sessionClaims } = await getAuth();
    if (userId) {
      return {
        userId,
        guestToken: null,  // Authenticated users don't use guest tokens
        tier: mapRoleToTier(sessionClaims?.metadata?.role),
        isAuthenticated: true
      };
    }
  } catch {
    // Auth not available - normal for unauthenticated requests
  }
  
  // Fallback to guest token or basic tier
  return {
    userId: null,
    guestToken,
    tier: 'basic',
    isAuthenticated: false
  };
}
```

### Usage Limit Checking
```typescript
// Check limits before allowing feature use
export async function enforceUsageLimit(
  context: RBACContext, 
  action: 'coreSessions' | 'premiumActions',
  count: number = 1
): Promise<void> {
  const limits = TIER_LIMITS[context.tier];
  const limit = limits[action];
  
  if (limit === -1) return; // Unlimited
  
  const currentUsage = await getCurrentUsage(context, action);
  
  if (currentUsage + count > limit) {
    throw new RBACError(`${action} limit exceeded: ${currentUsage}/${limit}`);
  }
  
  // Record usage
  await trackUsage(context, action, count);
}
```

## üîç Common RBAC Patterns

### Template Management
```typescript
// All template operations require signed_up or higher
if (req.nextUrl.pathname.startsWith('/api/templates') && req.method !== 'GET') {
  const role = sessionClaims?.metadata?.role || 'public';
  if (role === 'public') {
    return unauthorized();
  }
}
```

### Session Management  
```typescript
// Patient session access requires signed_up
if (req.nextUrl.pathname.startsWith('/api/patient-sessions')) {
  const { userId } = await auth();
  if (!userId) {
    return unauthorized();
  }
}
```

### Admin Operations
```typescript
// RAG admin operations require admin role
if (req.nextUrl.pathname.startsWith('/api/rag/admin')) {
  const role = sessionClaims?.metadata?.role || 'public';
  if (role !== 'admin') {
    return unauthorized();
  }
}
```

### Guest Token Support
```typescript
// Mobile and Ably routes support guest tokens
if (req.nextUrl.pathname.startsWith('/api/mobile') || 
    req.nextUrl.pathname.startsWith('/api/ably')) {
  // Authentication handled within individual route handlers
  return NextResponse.next();
}
```

## üö® RBAC Error Handling

### Error Types
```typescript
export class RBACError extends Error {
  constructor(message: string, public code: string = 'RBAC_ERROR') {
    super(message);
  }
}

export class UsageLimitError extends RBACError {
  constructor(action: string, used: number, limit: number) {
    super(`Usage limit exceeded for ${action}: ${used}/${limit}`);
    this.code = 'USAGE_LIMIT_EXCEEDED';
  }
}
```

### Client-Side Error Handling
```typescript
// Show upgrade prompts for usage limits
if (error.code === 'USAGE_LIMIT_EXCEEDED') {
  showModal(<UpgradeModal feature={error.action} />);
  return;
}

// Redirect for auth errors
if (error.code === 'UNAUTHORIZED') {
  router.push('/login?redirect=' + encodeURIComponent(pathname));
  return;
}
```

## üß™ Testing RBAC

### Role Testing Components
```typescript
// Use RoleTestingBanner for development
<RoleTestingBanner />

// Test with different roles
<RoleTestingProvider initialRole="signed_up">
  <Component />
</RoleTestingProvider>
```

### API Testing Pattern
```typescript
test('requires admin role', async () => {
  const response = await request
    .post('/api/admin/endpoint')
    .set('Authorization', 'Bearer invalid-token');
    
  expect(response.status).toBe(401);
  expect(response.body.error).toBe('Unauthorized');
});

test('enforces usage limits', async () => {
  // Simulate reaching limit
  await createUsageRecords(userId, 'coreSessions', 5);
  
  const response = await request
    .post('/api/consultation/generate')
    .set('Authorization', `Bearer ${validToken}`);
    
  expect(response.status).toBe(429);
  expect(response.body.code).toBe('USAGE_LIMIT_EXCEEDED');
});
```

## üìà Usage Analytics

### Tracking Implementation
```typescript
// Track usage for analytics and enforcement
export async function trackUsage(
  context: RBACContext,
  action: string,
  count: number
): Promise<void> {
  await db.insert(usageTracking).values({
    userId: context.userId,
    guestToken: context.guestToken,
    action,
    count,
    timestamp: new Date()
  });
}
```

### Usage Dashboard Data
```typescript
// Aggregate usage for dashboard
export async function getUserUsage(userId: string, period: 'day' | 'month') {
  const startDate = period === 'day' 
    ? startOfDay(new Date()) 
    : startOfMonth(new Date());
    
  return await db
    .select({
      action: usageTracking.action,
      total: sum(usageTracking.count)
    })
    .from(usageTracking)
    .where(
      and(
        eq(usageTracking.userId, userId),
        gte(usageTracking.timestamp, startDate)
      )
    )
    .groupBy(usageTracking.action);
}
```
description:
globs:
alwaysApply: false
---
